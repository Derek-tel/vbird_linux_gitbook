# 21.5 函数库管理

在我们的 Linux 操作系统当中，函数库是很重要的一个项目。 因为很多的软件之间都会互相取用彼此提供的函数库来进行特殊功能的运行， 例如很多需要验证身份的程序都习惯利用 PAM 这个模块提供的验证机制来实作，而很多网络连线机制则习惯利用 SSL 函数库来进行连线加密的机制。所以说，函数库的利用是很重要的。不过， 函数库又依照是否被编译到程序内部而分为动态与静态函数库，这两者之间有何差异？哪一种函数库比较好？ 下面我们就来谈一谈先！

## 21.5.1 动态与静态函数库

首先我们要知道的是，函数库的类型有哪些？依据函数库被使用的类型而分为两大类，分别是静态 （Static） 与动态 （Dynamic） 函数库两类。下面我们来谈一谈这两种类行的函数库吧！

-   静态函数库的特色：

-   **扩展名**：（扩展名为 .a） 这类的函数库通常扩展名为 libxxx.a 的类型；

-   **编译行为**： 这类函数库在编译的时候会直接整合到执行程序当中，所以利用静态函数库编译成的文件会比较大一些喔；

-   **独立执行的状态**： 这类函数库最大的优点，就是编译成功的可可执行文件可以独立执行，而不需要再向外部要求读取函数库的内容 （请参照动态函数库的说明）。

-   **升级难易度**： 虽然可执行文件可以独立执行，但因为函数库是直接整合到可执行文件中， 因此若函数库升级时，整个可执行文件必须要重新编译才能将新版的函数库整合到程序当中。 也就是说，在升级方面，只要函数库升级了，所有将此函数库纳入的程序都需要重新编译！

-   动态函数库的特色：

-   **扩展名**：（扩展名为 .so） 这类函数库通常扩展名为 libxxx.so 的类型；

-   **编译行为**： 动态函数库与静态函数库的编译行为差异挺大的。 与静态函数库被整个捉到程序中不同的，动态函数库在编译的时候，在程序里面只有一个“指向 （Pointer）”的位置而已。也就是说，动态函数库的内容并没有被整合到可执行文件当中，而是当可执行文件要使用到函数库的机制时， 程序才会去读取函数库来使用。由于可执行文件当中仅具有指向动态函数库所在的指标而已， 并不包含函数库的内容，所以他的文件会比较小一点。

-   **独立执行的状态**： 这类型的函数库所编译出来的程序不能被独立执行， 因为当我们使用到函数库的机制时，程序才会去读取函数库，所以函数库文件“必须要存在”才行，而且，函数库的“所在目录也不能改变”，因为我们的可可执行文件里面仅有“指标”亦即当要取用该动态函数库时， 程序会主动去某个路径下读取，呵呵！所以动态函数库可不能随意移动或删除，会影响很多相依的程序软件喔！

-   **升级难易度**： 虽然这类型的可执行文件无法独立运行，然而由于是具有指向的功能， 所以，当函数库升级后，可执行文件根本不需要进行重新编译的行为，因为可执行文件会直接指向新的函数库文件 （前提是函数库新旧版本的文件名相同喔！）。

目前的 Linux distribution 比较倾向于使用动态函数库，因为如同上面提到的最重要的一点， 就是函数库的升级方便！由于 Linux 系统里面的软件相依性太复杂了，如果使用太多的静态函数库，那么升级某一个函数库时， 都会对整个系统造成很大的冲击！因为其他相依的可执行文件也要同时重新编译啊！ 这个时候动态函数库可就有用多了，因为只要动态函数库升级就好，其他的软件根本无须变动。

那么这些函数库放置在哪里呢？绝大多数的函数库都放置在：/lib64, /lib 目录下！ 此外，Linux 系统里面很多的函数库其实 kernel 就提供了，那么 kernel 的函数库放在哪里？呵呵！就是在 /lib/modules 里面啦！里面的数据可多着呢！不过要注意的是， 不同版本的核心提供的函数库差异性是挺大的，所以 kernel 2.4.xx 版本的系统不要想将核心换成 2.6.xx 喔！ 很容易由于函数库的不同而导致很多原本可以执行的软件无法顺利运行呢！

## 21.5.2 ldconfig 与 /etc/ld.so.conf

在了解了动态与静态函数库，也知道我们目前的 Linux 大多是将函数库做成动态函数库之后，再来要知道的就是，那有没有办法增加函数库的读取性能？ 我们知道内存的存取速度是硬盘的好几倍，所以，如果我们将常用到的动态函数库先载入内存当中 （高速缓存, cache），如此一来，当软件要取用动态函数库时，就不需要从头由硬盘里面读出啰！ 这样不就可以增进动态函数库的读取速度？没错，是这样的！这个时候就需要 ldconfig 与 /etc/ld.so.conf 的协助了。

如何将动态函数库载入高速缓存内存当中呢？

1.  首先，我们必须要在 /etc/ld.so.conf 里面写下“ 想要读入高速缓存内存当中的动态函数库所在的目录”，注意喔， 是目录而不是文件；
2.  接下来则是利用 ldconfig 这个可执行文件将 /etc/ld.so.conf 的数据读入高速缓存当中；
3.  同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中呐！

![使用 ldconfig 预载入动态函数库到内存中](/pic/ldconfig.gif)  
*图21.5.1、使用 ldconfig 预载入动态函数库到内存中*

事实上， ldconfig 还可以用来判断动态函数库的链接信息呢！赶紧利用 CentOS 来测试看看。假设你想要将目前你系统下的 mariadb 函数库加入到高速缓存当中时，可以这样做：

```shell
[root@study ~]# ldconfig [-f conf] [ -C cache]
[root@study ~]# ldconfig [-p]
选项与参数：
-f conf ：那个 conf 指的是某个文件名称，也就是说，使用 conf 作为 libarary 
      函数库的取得路径，而不以 /etc/ld.so.conf 为默认值
-C cache：那个 cache 指的是某个文件名称，也就是说，使用 cache 作为高速缓存暂存
      的函数库数据，而不以 /etc/ld.so.cache 为默认值
-p    ：列出目前有的所有函数库数据内容 （在 /etc/ld.so.cache 内的数据！）

范例一：假设我的 Mariadb 数据库函数库在 /usr/lib64/mysql 当中，如何读进 cache ？
[root@study ~]# vim /etc/ld.so.conf.d/vbird.conf
/usr/lib64/mysql   <==这一行新增的啦！

[root@study ~]# ldconfig  <==画面上不会显示任何的信息，不要太紧张！正常的！

[root@study ~]# ldconfig -p
924 libs found in cache `/etc/ld.so.cache'
        p11-kit-trust.so （libc6,x86-64） => /lib64/p11-kit-trust.so
        libzapojit-0.0.so.0 （libc6,x86-64） => /lib64/libzapojit-0.0.so.0
....（下面省略）....
#       函数库名称 => 该函数库实际路径
```

通过上面的动作，我们可以将 Mariadb 的相关函数库给他读入高速缓存当中，这样可以加快函数库读取的效率呢！ 在某些时候，你可能会自行加入某些 Tarball 安装的动态函数库，而你想要让这些动态函数库的相关链接可以被读入到高速缓存当中， 这个时候你可以将动态函数库所在的目录名称写入 /etc/ld.so.conf.d/yourfile.conf 当中，然后执行 ldconfig 就可以啦！

## 21.5.3 程序的动态函数库解析： ldd

说了这么多，那么我如何判断某个可执行的 binary 文件含有什么动态函数库呢？很简单，利用 ldd 就可以晓得了！例如我想要知道 /usr/bin/passwd 这个程序含有的动态函数库有哪些，可以这样做：

```shell
[root@study ~]# ldd [-vdr] [filename]
选项与参数：
-v ：列出所有内容信息；
-d ：重新将数据有遗失的 link 点秀出来！
-r ：将 ELF 有关的错误内容秀出来！

范例一：找出 /usr/bin/passwd 这个文件的函数库数据
[root@study ~]# ldd /usr/bin/passwd
....（前面省略）....
        libpam.so.0 => /lib64/libpam.so.0 （0x00007f5e683dd000）            <==PAM 模块
        libpam_misc.so.0 => /lib64/libpam_misc.so.0 （0x00007f5e681d8000）
        libaudit.so.1 => /lib64/libaudit.so.1 （0x00007f5e67fb1000）        <==SELinux
        libselinux.so.1 => /lib64/libselinux.so.1 （0x00007f5e67d8c000）    <==SELinux
....（下面省略）....
# 我们前言的部分不是一直提到 passwd 有使用到 pam 的模块吗！怎么知道？
# 利用 ldd 察看一下这个文件，看到 libpam.so 了吧？这就是 pam 提供的函数库

范例二：找出 /lib64/libc.so.6 这个函数的相关其他函数库！
[root@study ~]# ldd -v /lib64/libc.so.6
        /lib64/ld-linux-x86-64.so.2 （0x00007f7acc68f000）
        linux-vdso.so.1 =>  （0x00007fffa975b000）

        Version information:  <==使用 -v 选项，增加显示其他版本信息！
        /lib64/libc.so.6:
                ld-linux-x86-64.so.2 （GLIBC_2.3） => /lib64/ld-linux-x86-64.so.2
                ld-linux-x86-64.so.2 （GLIBC_PRIVATE） => /lib64/ld-linux-x86-64.so.2
```

未来如果你常常升级安装 RPM 的软件时 （下一章节会介绍），应该常常会发现那个“ 相依属性”的问题吧！没错！我们可以先以 ldd 来视察“相依函数库”之间的相关性！以先取得了解！ 例如上面的例子中，我们检查了 libc.so.6 这个在 /lib64 当中的函数库，结果发现他其实还跟 ld-linux-x86-64.so.2 有关！所以我们就需要来了解一下，那个文件到底是什么软件的函数库呀？使用 -v 这个参数还可以得知该函数库来自于哪一个软件！像上面的数据中，就可以得到该 libc.so.6 其实可以支持 GLIBC_2.3 等的版本！