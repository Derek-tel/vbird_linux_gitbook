# 16.2 工作管理 （job control）

这个工作管理 （job control） 是用在 bash 环境下的，也就是说：“当我们登陆系统取得 bash shell 之后，在单一终端机接口下同时进行多个工作的行为管理 ”。举例来说，我们在登陆 bash 后， 想要一边复制文件、一边进行数据搜寻、一边进行编译，还可以一边进行 vim 程序撰写！ 当然我们可以重复登陆那六个命令行的终端机环境中，不过，能不能在一个 bash 内达成？ 当然可以啊！就是使用 job control 啦！ ^\_^

## 16.2.1 什么是工作管理？

从上面的说明当中，你应该要了解的是：“进行工作管理的行为中， 其实每个工作都是目前 bash 的子程序，亦即彼此之间是有相关性的。 我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash ！” 这个概念请你得先创建起来，后续的范例介绍之后，你就会清楚的了解啰！

或许你会觉得很奇怪啊，既然我可以在六个终端接口登陆，那何必使用 job control 呢？ 真是脱裤子放屁，多此一举啊！不要忘记了呢，我们可以在 [/etc/security/limits.conf （第十三章）] 里面设置使用者同时可以登陆的连线数，在这样的情况下，某些使用者可能仅能以一个连线来工作呢！ 所以啰，你就得要了解一下这种工作管理的模式了！此外，这个章节内容也会牵涉到很多的数据流重导向，所以，如果忘记的话， 务必回到[第十章 BASH Shell] 看一看喔！

由于假设我们只有一个终端接口，因此在可以出现提示字符让你操作的环境就称为前景 （foreground），至于其他工作就可以让你放入背景 （background） 去暂停或运行。要注意的是，放入背景的工作想要运行时， 他必须不能够与使用者互动。举例来说， vim 绝对不可能在背景里面执行 （running） 的！因为你没有输入数据他就不会跑啊！ 而且放入背景的工作是不可以使用 \[ctrl\]+c 来终止的！

总之，要进行 bash 的 job control 必须要注意到的限制是：

-   这些工作所触发的程序必须来自于你 shell 的子程序（只管理自己的 bash）；
-   前景：你可以控制与下达指令的这个环境称为前景的工作 （foreground）；
-   背景：可以自行运行的工作，你无法使用 \[ctrl\]+c 终止他，可使用 bg/fg 调用该工作；
-   背景中“执行”的程序不能等待 terminal/shell 的输入（input）

接下来让我们实际来管理这些工作吧！

## 16.2.2 job control 的管理

如前所述，bash 只能够管理自己的工作而不能管理其他 bash 的工作，所以即使你是 root 也不能够将别人的 bash 下面的 job 给他拿过来执行。此外，又分前景与背景，然后在背景里面的工作状态又可以分为“暂停 （stop）”与“运行中 （running）”。那实际进行 job 控制的指令有哪些？下面就来谈谈。

-   直接将指令丢到背景中“执行”的 &

如同前面提到的，我们在只有一个 bash 的环境下，如果想要同时进行多个工作， 那么可以将某些工作直接丢到背景环境当中，让我们可以继续操作前景的工作！那么如何将工作丢到背景中？ 最简单的方法就是利用“ & ”这个玩意儿了！举个简单的例子，我们要将 /etc/ 整个备份成为 /tmp/etc.tar.gz 且不想要等待，那么可以这样做：

```shell
[root@study ~]# tar -zpcf /tmp/etc.tar.gz /etc &
[1] 14432  <== [job number] PID 
[root@study ~]# tar: Removing leading `/' from member names 
# 在中括号内的号码为工作号码 （job number），该号码与 bash 的控制有关。
# 后续的 14432 则是这个工作在系统中的 PID。至于后续出现的数据是 tar 执行的数据流，
# 由于我们没有加上数据流重导向，所以会影响画面！不过不会影响前景的操作喔！
```

仔细的瞧一瞧，我在输入一个指令后，在该指令的最后面加上一个“ & ”代表将该指令丢到背景中， 此时 bash 会给予这个指令一个“工作号码（job number）”，就是那个 \[1\] 啦！至于后面那个 14432 则是该指令所触发的“ PID ”了！而且，有趣的是，我们可以继续操作 bash 呢！很不赖吧！ 不过，那么丢到背景中的工作什么时候完成？完成的时候会显示什么？如果你输入几个指令后，突然出现这个数据：

```shell
[1]+  Done                    tar -zpcf /tmp/etc.tar.gz /etc
```

就代表 \[1\] 这个工作已经完成 （Done） ，该工作的指令则是接在后面那一串命令行。 这样了解了吧！另外，这个 & 代表：“将工作丢到背景中去执行”喔！ 注意到那个“执行”的字眼！此外，这样的情况最大的好处是： 不怕被 \[ctrl\]+c 中断的啦！ 此外，将工作丢到背景当中要特别注意数据的流向喔！包括上面的讯息就有出现错误讯息，导致我的前景被影响。 虽然只要按下 \[enter\] 就会出现提示字符。但如果我将刚刚那个指令改成：

```shell
[root@study ~]# tar -zpcvf /tmp/etc.tar.gz /etc &
```

情况会怎样？在背景当中执行的指令，如果有 stdout 及 stderr 时，他的数据依旧是输出到屏幕上面的， 所以，我们会无法看到提示字符，当然也就无法完好的掌握前景工作。同时由于是背景工作的 tar ， 此时你怎么按下 \[ctrl\]+c 也无法停止屏幕被搞的花花绿绿的！所以啰，最佳的状况就是利用数据流重导向， 将输出数据传送至某个文件中。举例来说，我可以这样做：

```shell
[root@study ~]# tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &
[1] 14547
[root@study ~]#
```

呵呵！如此一来，输出的信息都给他传送到 /tmp/log.txt 当中，当然就不会影响到我们前景的作业了。 这样说，您应该可以更清楚数据流重导向的重要性了吧！^\_^



> [!TIP]  
> 工作号码 （job number） 只与你这个 bash 环境有关，但是他既然是个指令触发的咚咚，所以当然一定是一个程序， 因此你会观察到有 job number 也搭配一个 PID ！

-   将“目前”的工作丢到背景中“暂停”：\[ctrl\]-z

想个情况：如果我正在使用 vim ，却发现我有个文件不知道放在哪里，需要到 bash 环境下进行搜寻，此时是否要结束 vim 呢？呵呵！当然不需要啊！只要暂时将 vim 给他丢到背景当中等待即可。 例如以下的案例：

```shell
[root@study ~]# vim  ~/.bashrc
# 在 vim 的一般模式下，按下 [ctrl]-z 这两个按键
[1]+  Stopped                 vim ~/.bashrc
[root@study ~]#   <==顺利取得了前景的操控权！
[root@study ~]# find / -print
....（输出省略）....
# 此时屏幕会非常的忙碌！因为屏幕上会显示所有的文件名。请按下 [ctrl]-z 暂停
[2]+  Stopped                 find / -print
```

在 vim 的一般模式下，按下 \[ctrl\] 及 z 这两个按键，屏幕上会出现 \[1\] ，表示这是第一个工作， 而那个 + 代表最近一个被丢进背景的工作，且目前在背景下默认会被取用的那个工作 （与 fg 这个指令有关 ）！而那个 Stopped 则代表目前这个工作的状态。在默认的情况下，使用 \[ctrl\]-z 丢到背景当中的工作都是“暂停”的状态喔！

-   观察目前的背景工作状态： jobs

```shell
[root@study ~]# jobs [-lrs]
选项与参数：
-l  ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
-r  ：仅列出正在背景 run 的工作；
-s  ：仅列出正在背景当中暂停 （stop） 的工作。

范例一：观察目前的 bash 当中，所有的工作，与对应的 PID
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
```

如果想要知道目前有多少的工作在背景当中，就用 jobs 这个指令吧！一般来说，直接下达 jobs 即可！ 不过，如果你还想要知道该 job number 的 PID 号码，可以加上 -l 这个参数啦！ 在输出的信息当中，例如上表，仔细看到那个 + - 号喔！那个 + 代表默认的取用工作。 所以说：“目前我有两个工作在背景当中，两个工作都是暂停的， 而如果我仅输入 fg 时，那么那个 \[2\] 会被拿到前景当中来处理”！

其实 + 代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码。 而超过最后第三个以后的工作，就不会有 +/- 符号存在了！

-   将背景工作拿到前景来处理：fg

刚刚提到的都是将工作丢到背景当中去执行的，那么有没有可以将背景工作拿到前景来处理的？ 有啊！就是那个 fg （foreground） 啦！举例来说，我们想要将上头范例当中的工作拿出来处理时：

```shell
[root@study ~]# fg %jobnumber
选项与参数：
%jobnumber ：jobnumber 为工作号码（数字）。注意，那个 % 是可有可无的！

范例一：先以 jobs 观察工作，再将工作取出：
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
[root@study ~]# fg      <==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
[root@study ~]# fg %1   <==直接规定取出的那个工作号码！再按下[ctrl]-z
[root@study ~]# jobs -l
[1]+ 14566 Stopped                 vim ~/.bashrc
[2]- 14567 Stopped                 find / -print
```

经过 fg 指令就能够将背景工作拿到前景来处理啰！不过比较有趣的是最后一个显示的结果，我们会发现 + 出现在第一个工作后！ 怎么会这样啊？这是因为你刚刚利用 fg %1 将第一号工作捉到前景后又放回背景，此时最后一个被放入背景的将变成 vi 那个指令动作， 所以当然 \[1\] 后面就会出现 + 了！了解乎！另外，如果输入“ fg - ” 则代表将 - 号的那个工作号码拿出来，上面就是 \[2\]- 那个工作号码啦！

-   让工作在背景下的状态变成运行中： bg

我们刚刚提到，那个 \[ctrl\]-z 可以将目前的工作丢到背景下面去“暂停”， 那么如何让一个工作在背景下面“ Run ”呢？我们可以在下面这个案例当中来测试！ 注意喔！下面的测试要进行的快一点！^\_^

```shell
范例一：一执行 find / -perm /7000 > /tmp/text.txt 后，立刻丢到背景去暂停！
[root@study ~]# find / -perm /7000 > /tmp/text.txt
# 此时，请立刻按下 [ctrl]-z 暂停！
[3]+  Stopped                 find / -perm /7000 > /tmp/text.txt

范例二：让该工作在背景下进行，并且观察他！！
[root@study ~]# jobs ; bg %3 ; jobs
[1]   Stopped                 vim ~/.bashrc
[2]-  Stopped                 find / -print
[3]+  Stopped                 find / -perm /7000 > /tmp/text.txt
[3]+ find / -perm /7000 > /tmp/text.txt &
[1]-  Stopped                 vim ~/.bashrc
[2]+  Stopped                 find / -print
[3]   Running                 find / -perm /7000 > /tmp/text.txt &
```

看到哪里有差异吗？呼呼！没错！就是那个状态列～以经由 Stopping 变成了 Running 啰！ 看到差异点，嘿嘿！命令行最后方多了一个 & 的符号啰！ 代表该工作被启动在背景当中了啦！ ^\_^

-   管理背景当中的工作： kill

刚刚我们可以让一个已经在背景当中的工作继续工作，也可以让该工作以 fg 拿到前景来， 那么，如果想要将该工作直接移除呢？或者是将该工作重新启动呢？这个时候就得需要给予该工作一个讯号 （signal） ，让他知道该怎么作才好啊！此时， kill 这个指令就派上用场啦！

```shell
[root@study ~]# kill -signal %jobnumber
[root@study ~]# kill -l
选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置文件 （类似 reload）；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的。

范例一：找出目前的 bash 环境下的背景工作，并将该工作“强制删除”。
[root@study ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[root@study ~]# kill -9 %2; jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Killed                  find / -print
# 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！

范例二：找出目前的 bash 环境下的背景工作，并将该工作“正常终止”掉。
[root@study ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[root@study ~]# kill -SIGTERM %1
# -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
# 不过在这个案例中， vim 的工作无法被结束喔！因为他无法通过 kill 正常终止的意思！
```

特别留意一下， -9 这个 signal 通常是用在“强制删除一个不正常的工作”时所使用的， -15 则是以正常步骤结束一项工作（15也是默认值），两者之间并不相同呦！举上面的例子来说， 我用 vim 的时候，不是会产生一个 .filename.swp 的文件吗？ 那么，当使用 -15 这个 signal 时， vim 会尝试以正常的步骤来结束掉该 vi 的工作， 所以 .filename.swp 会主动的被移除。但若是使用 -9 这个 signal 时，由于该 vim 工作会被强制移除掉，因此， .filename.swp 就会继续存在文件系统当中。这样您应该可以稍微分辨一下了吧？

不过，毕竟正常的作法中，你应该先使用 fg 来取回前景控制权，然后再离开 vim 才对～因此，以上面的范例二为例，其实 kill 确实无法使用 -15 正常的结束掉 vim 的动作喔！此时还是不建议使用 -9 啦！因为你知道如何正常结束该程序不是吗？ 通常使用 -9 是因为某些程序你真的不知道怎么通过正常手段去终止他，这才用到 -9 的！

其实， kill 的妙用是很无穷的啦！他搭配 signal 所详列的信息 （用 man 7 signal 去查阅相关数据） 可以让您有效的管理工作与程序 （Process），此外，那个 killall 也是同样的用法！ 至于常用的 signal 您至少需要了解 1, 9, 15 这三个 signal 的意义才好。 此外， signal 除了以数值来表示之外，也可以使用讯号名称喔！ 举例来说，上面的范例二就是一个例子啦！至于 signal number 与名称的对应， 呵呵，使用 kill -l 就知道啦（L的小写）！

另外， kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就得要加上 %数字 了， 这点也得特别留意才行喔！

## 16.2.3 离线管理问题

要注意的是，我们在工作管理当中提到的“背景”指的是在终端机模式下可以避免 \[crtl\]-c 中断的一个情境， 你可以说那个是 bash 的背景，并不是放到系统的背景去喔！所以，工作管理的背景依旧与终端机有关啦！ 在这样的情况下，如果你是以远端连线方式连接到你的 Linux 主机，并且将工作以 & 的方式放到背景去， 请问，在工作尚未结束的情况下你离线了，该工作还会继续进行吗？答案是“否”！不会继续进行，而是会被中断掉。

那怎么办？如果我的工作需要进行一大段时间，我又不能放置在背景下面，那该如何处理呢？ 首先，你可以参考前一章的 [at] 来处理即可！因为 at 是将工作放置到系统背景， 而与终端机无关。如果不想要使用 at 的话，那你也可以尝试使用 nohup 这个指令来处理喔！这个 nohup 可以让你在离线或登出系统后，还能够让工作继续进行。他的语法有点像这样：

```shell
[root@study ~]# nohup [指令与参数]   <==在终端机前景中工作
[root@study ~]# nohup [指令与参数] & <==在终端机背景中工作
```

有够好简单的指令吧！上述指令需要注意的是， nohup 并不支持 bash 内置的指令，因此你的指令必须要是外部指令才行。 我们来尝试玩一下下面的任务吧！

```shell
# 1\. 先编辑一支会“睡着 500 秒”的程序：
[root@study ~]# vim sleep500.sh
#!/bin/bash
/bin/sleep 500s
/bin/echo "I have slept 500 seconds."

# 2\. 丢到背景中去执行，并且立刻登出系统：
[root@study ~]# chmod a+x sleep500.sh
[root@study ~]# nohup ./sleep500.sh &
[2] 14812
[root@study ~]#  nohup: ignoring input and appending output to `nohup.out' <==会告知这个讯息！
[root@study ~]# exit
```

如果你再次登陆的话，再使用 pstree 去查阅你的程序，会发现 sleep500.sh 还在执行中喔！并不会被中断掉！ 这样了解意思了吗？由于我们的程序最后会输出一个讯息，但是 nohup 与终端机其实无关了， 因此这个讯息的输出就会被导向“ \~/nohup.out ”，所以你才会看到上述指令中，当你输入 nohup 后， 会出现那个提示讯息啰。

如果你想要让在背景的工作在你登出后还能够继续的执行，那么使用 nohup 搭配 & 是不错的运行情境喔！ 可以参考看看！